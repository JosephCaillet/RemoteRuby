// Generated by CoffeeScript 1.4.0
(function() {
  var RR_AppendText, RR_BindEventListener, RR_LoadJQuerry, RR_Main, RR_RunEvent, RR_SetupInteractionZone, RR_StdinEvent, RR_StopEvent, prefix, socket;

  socket = void 0;

  prefix = '.present ';

  RR_Main = function() {
    socket = io.connect('http://localhost:8080');
    $('head').append('<link rel="stylesheet" href="plugin/remote-ruby/remote-ruby.css" type="text/css" />');
    RR_SetupInteractionZone();
    return RR_BindEventListener();
  };

  RR_SetupInteractionZone = function() {
    var interactionZoneBegin, interactionZoneEnd, interactionZoneStdinButton;
    interactionZoneBegin = '<div class="RR_InteractionZone">\
			<button class="RR_RunButton">Run</button>\
			<button class="RR_StopButton">Stop</button>\
			<button class="RR_ClearButton">Clear</button>\
\
			<pre class="RR_Stdout"></pre>';
    interactionZoneStdinButton = '<input type="text" class="RR_Stdin" placeholder="Input goes here">';
    interactionZoneEnd = '</div>';
    return $('.RR_RubyCode').each(function() {
      if ($(this).hasClass("RR_FullIO")) {
        return $(this).parent().after(interactionZoneBegin + interactionZoneStdinButton + interactionZoneEnd);
      } else {
        return $(this).parent().after(interactionZoneBegin + interactionZoneEnd);
      }
    });
  };

  RR_AppendText = function(txt, newline) {
    var msg, stdout;
    msg = $(prefix + '.RR_Stdout').html() + txt;
    if (newline === true) {
      msg += '\n';
    }
    stdout = $(prefix + '.RR_Stdout');
    stdout.html(msg);
    return stdout.scrollTop(stdout.prop("scrollHeight"));
  };

  RR_BindEventListener = function() {
    $('.RR_RunButton').click(RR_RunEvent);
    $('.RR_StopButton').click(RR_StopEvent);
    $('.RR_Stdin').keydown(function(e) {
      if (e.keyCode === 13) {
        return RR_StdinEvent();
      }
    });
    $('.RR_ClearButton').click(function() {
      return $(prefix + '.RR_Stdout').html('');
    });
    socket.on('stdout', function(output) {
      return RR_AppendText(output);
    });
    socket.on('stderr', function(output) {
      return RR_AppendText(output);
    });
    socket.on('terminated', function(message) {
      return RR_AppendText(message, true);
    });
    return socket.on('approvedInput', function(input) {
      $(prefix + '.RR_Stdin').val("");
      return RR_AppendText(input, true);
    });
  };

  RR_RunEvent = function() {
    /*
    	highlight.js is pretty cool, but it behave in a strange way when you try to edit code element,
        because it does not add newline character, which is very annoying for the ruby interpreter...
        that's why we change every div created by highlight.js with a div containing a br element,
        and we replace all br element with the newline character. This may create too much new line characters,
        but it's not a big problem. It's the only solution I have found, if you know an other let me know ;)
    */

    var newContent, rubyCodeCloneElement, rubyCodeHtml;
    rubyCodeHtml = $(prefix + '.RR_RubyCode').html();
    rubyCodeCloneElement = $('<div>').html(rubyCodeHtml);
    newContent = rubyCodeCloneElement.html().replace(/<div>/mg, "<div><br>").replace(/<br\s*\/?>/mg, "\n");
    rubyCodeCloneElement.html(newContent);
    return socket.emit('run', $(prefix + '.RR_HiddenRubyCode').text() + rubyCodeCloneElement.text());
  };

  RR_StopEvent = function() {
    return socket.emit('stop');
  };

  RR_StdinEvent = function() {
    return socket.emit('stdin', $(prefix + '.RR_Stdin').val());
  };

  RR_LoadJQuerry = function() {
    var headTag, jqTag;
    headTag = document.getElementsByTagName("head")[0];
    jqTag = document.createElement('script');
    jqTag.type = 'text/javascript';
    jqTag.src = 'https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js';
    jqTag.onload = function() {
      return $(RR_Main);
    };
    return headTag.appendChild(jqTag);
  };

  if (typeof jQuery === 'undefined') {
    RR_LoadJQuerry();
  } else {
    $(RR_Main);
  }

}).call(this);
