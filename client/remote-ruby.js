// Generated by CoffeeScript 1.9.3
(function() {
  var RR_AppendText, RR_BindEventListener, RR_GetCurrentSlide, RR_LoadJQuerry, RR_Main, RR_RunEvent, RR_SetupInteractionZone, RR_StdinEvent, RR_StopEvent, prefix, socket;

  socket = void 0;

  prefix = '.present ';

  RR_Main = function() {
    $('head').append('<link rel="stylesheet" href="plugin/remote-ruby/remote-ruby.css" type="text/css" />');
    socket = io.connect('http://localhost:8080');
    RR_SetupInteractionZone();
    return RR_BindEventListener();
  };

  RR_SetupInteractionZone = function() {
    var interactionZoneBegin, interactionZoneEnd, interactionZoneStdinButton;
    interactionZoneBegin = '<div class="RR_InteractionZone"> <button class="RR_RunButton">Run</button> <button class="RR_StopButton">Stop</button> <button class="RR_ClearButton">Clear</button> <pre class="RR_Stdout"></pre>';
    interactionZoneStdinButton = '<input type="text" class="RR_Stdin" placeholder="Input goes here">';
    interactionZoneEnd = '</div>';
    return $('.RR_RubyCode').each(function() {
      if ($(this).hasClass("RR_FullIO")) {
        return $(this).parent().after(interactionZoneBegin + interactionZoneStdinButton + interactionZoneEnd);
      } else {
        return $(this).parent().after(interactionZoneBegin + interactionZoneEnd);
      }
    });
  };

  RR_GetCurrentSlide = function(selector) {
    if ($('.stack' + prefix + '>' + prefix).html() !== void 0) {
      console.log("sub: " + selector);
      return $('.stack' + '>' + prefix + selector);
    } else {
      console.log("non: " + selector);
      return $(prefix + selector);
    }

    /*
    	currentSlide = $('.stack' + '>' + prefix + selector)
    	#console.log("2:"+prefix + '>' + prefix + selector)
    	if currentSlide.html() == undefined
    		currentSlide = $(prefix + selector)
    		console.log("non: " + selector)
    	else
    		console.log("sub: " + selector)
    
    	#console.log(currentSlide)
    	console.log("------")
    	return currentSlide
     */
  };

  RR_AppendText = function(txt, newline) {
    var msg, stdout;
    msg = RR_GetCurrentSlide('.RR_Stdout').html() + txt;
    if (newline === true) {
      msg += '\n';
    }
    stdout = RR_GetCurrentSlide('.RR_Stdout');
    stdout.html(msg);
    return stdout.scrollTop(stdout.prop("scrollHeight"));
  };

  RR_BindEventListener = function() {
    $('.RR_RunButton').click(RR_RunEvent);
    $('.RR_StopButton').click(RR_StopEvent);
    $('.RR_Stdin').keydown(function(e) {
      if (e.keyCode === 13) {
        return RR_StdinEvent();
      }
    });
    $('.RR_ClearButton').click(function() {
      return RR_GetCurrentSlide('.RR_Stdout').html('');
    });
    socket.on('stdout', function(output) {
      return RR_AppendText(output);
    });
    socket.on('stderr', function(output) {
      return RR_AppendText(output);
    });
    socket.on('terminated', function(message) {
      RR_AppendText(message, true);
      return document.activeElement.blur();
    });
    return socket.on('approvedInput', function(input) {
      RR_GetCurrentSlide('.RR_Stdin').val("");
      return RR_AppendText(input, true);
    });
  };

  RR_RunEvent = function() {

    /*
    	highlight.js is pretty cool, but it behave in a strange way when you try to edit code element,
       because it does not add newline character, which is very annoying for the ruby interpreter...
       that's why we change every div created by highlight.js with a div containing a br element,
       and we replace all br element with the newline character. This may create too much new line characters,
       but it's not a big problem. It's the only solution I have found, if you know an other let me know ;)
     */

    /*
    	console.log("1:"+ prefix + '>' + prefix + '.RR_RubyCode')
    	rubyCodeHtml = $(prefix + '>' + prefix + '.RR_RubyCode').html()
    	if rubyCodeHtml == undefined
    		rubyCodeHtml = $(prefix + '.RR_RubyCode').html()
     */
    var newContent, rubyCodeCloneElement, rubyCodeHtml;
    rubyCodeHtml = RR_GetCurrentSlide('.RR_RubyCode').html();
    rubyCodeCloneElement = $('<div>').html(rubyCodeHtml);
    newContent = rubyCodeCloneElement.html().replace(/<div>/mg, "<div><br>").replace(/<br\s*\/?>/mg, "\n");
    rubyCodeCloneElement.html(newContent);
    return socket.emit('run', RR_GetCurrentSlide('.RR_HiddenRubyCode').text() + rubyCodeCloneElement.text());
  };

  RR_StopEvent = function() {
    return socket.emit('stop');
  };

  RR_StdinEvent = function() {
    return socket.emit('stdin', RR_GetCurrentSlide('.RR_Stdin').val());
  };

  RR_LoadJQuerry = function() {
    var headTag, jqTag;
    headTag = document.getElementsByTagName("head")[0];
    jqTag = document.createElement('script');
    jqTag.type = 'text/javascript';
    jqTag.src = 'https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js';
    jqTag.onload = function() {
      return $(RR_Main);
    };
    return headTag.appendChild(jqTag);
  };

  if (typeof jQuery === 'undefined') {
    RR_LoadJQuerry();
  } else {
    $(RR_Main);
  }

}).call(this);
